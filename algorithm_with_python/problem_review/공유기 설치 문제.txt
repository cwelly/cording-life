처음 이문제를 봤을때 나의 접근 방식은
"주어진 공유기의 갯수만큼 모든 경우의 수를 시험해 보고 최적의 값을 고르자" 였다.
하지만 입력으로 주어지는 숫자의 갯수가 10억개를 넘어가므로, 이는 불가능했다.

책에서의 해결법은 이런 큰 범위일땐 이진탐색으로 방향을 잡아야 한다는 것이었고,

먼저 '가장 인접한 공유기 사이의 거리'를 이진탐색으로 찾는 것이다. 

범위 (start ~ end) 는 최소 갭과 최대 갭을 시작으로 조절해 가고,

목표는 (target) 은 설정한 값(설정한 갭대로 설치한 공유기의 수)로 
확인해서 루프의 탈출을 결정하고

mid 값은, 현재 설정된 갭값(mid) 간격으로 설치한 공유기의 수가 target값 보다 크다면
(  == 공유기를 많이 설치함 == 갭이 너무 작아서 촘촘히 설치 됨 == 갭을 늘려야 됨 ) 
start =mid+1 하고 갭값의 범위를 큰쪽으로 좁힌다. 
(이와 동시에 현재 갭값(mid)으로 설치하면 그나마 최댓값은 아니지만 후보값은 성립하므로 result에 추가한다)

공유기의 수가 target값보다 작다면
( == 공유기를 적게 설치함 == 갭이 너무 커서 띄엄띄엄 설치 됨 == 갭을 줄여야됨)
end=mid-1 하고 갭값의 범위를 작은쪽으로 좁힌다.
(최댓값은 될수 있겠지만, 공유기의 수가 부족하므로 result 값 후보가 될순 없다)

